Critical Issues (Must Address for Robust Demo)

1. Incomplete Simulator Instruction Set (Most Critical): While the m6800_assembler.py supports a very comprehensive set of M6800, M6801, and M6811 instructions (including various addressing modes for each), the simulator.py only implements a subset of these. Many fundamental M6800 instructions, even though they have opcodes and are handled by the assembler, are not present in the _execute_instruction method of the simulator for all their supported addressing modes.

-> Examples of missing simulator implementations (for instructions correctly handled by assembler):

(*) All ADC (Add with Carry) modes.
(*) Most ADD modes (only IMM for A/B are in sim, not DIR, EXT, IDX).
(*) All AND, BIT, EOR, ORA, SBC, SUB (except SUBA DIR, SUBB EXT) modes.
(*) Most ASL, ASR, LSR, ROL, ROR modes (only accumulator INH are in sim, not DIR, EXT, IDX).
(*) CLR, COM, NEG, INC, DEC (only accumulator INH are in sim, not DIR, EXT, IDX).
(*) CBA (Compare A with B).
(*) CLC, CLI, SEI, SEC, SEV (Condition Code operations).
(*) TAP, TPA (Transfer A to/from CC).
(*) JSR (Jump to Subroutine - both EXT and IDX modes, defined in assembler but missing in simulator).
(*) BSR (Branch to Subroutine - Relative mode, defined in assembler but missing in simulator).
(*) TST (Test - DIR, EXT, IDX modes for memory, assembler correctly removed DIR but has EXT/IDX/INH for A/B, simulator only has NEGA/B for inherent).

1.2. CPD Instruction in Simulator (M6811): The assembler defines CPD (Compare D register) with opcode 0x1A83 (for immediate) and others. However, the simulator only has 0x18 as a prefix handler for M6811 extended instructions, not 0x1A. So, CPD instructions will currently be seen as "Unknown opcode".
Recommendation: Add a elif opcode == 0x1A: block to _execute_instruction to handle CPD and other potential 0x1A prefixed instructions.


2. Non-Critical / Logical Issues (Good to Refine)

2.1. Assembler Parsing Consistency for Bit Manipulation Instructions:  In _first_pass and _second_pass, there's custom logic to parse operands for BSET, BCLR, BRSET, BRCLR (Lines 283-318 and 446-480). This logic is repeated and bypasses the general _parse_operand function.
Recommendation: Refactor _parse_operand to handle these multi-part operands or create a dedicated helper for them that is called from _assemble_instruction and _calculate_instruction_size.

2.2. H (Half-Carry) Flag Handling:  The H flag (bit 5 in CC) is included in _pack_cc_register and _unpack_cc_register, and DAA uses it, but no instruction explicitly sets or clears the H flag during arithmetic operations (e.g., ADD, ADC).
Recommendation: For a truly accurate simulator, H should be updated by relevant arithmetic instructions (like ADD, ADC, ABA) based on the carry from bit 3 to bit 4.

2.3. I (Interrupt Mask) Flag Handling: Similar to H, the I flag (bit 4 in CC) is included but not actively manipulated by instructions like SEI (Set Interrupt Mask) or CLI (Clear Interrupt Mask), which the assembler supports. SWI sets it, but that's the only place.
Recommendation: Implement SEI and CLI in _execute_instruction to correctly set/clear cc_flags['I'].